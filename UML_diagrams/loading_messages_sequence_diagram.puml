@startuml
' Sequence diagram for loading messages
actor LI
participant FE
participant BE
participant DB as "DB(SQL)"
participant AGENT
participant MCP

LI <- FE: sees thread is open
FE -> FE: Find msgID, sender_name, date, time, thread_name, msg_content for each message in thread
FE -> BE: Send msg [{...}]
BE -> DB: Does message already exist?
note right: BE gets multiple messages in an array per call. It only needs to start the entire process once for each thread, if there are one or more new messages in that thread. If there are 3 new messages for a single thread, the process runs one time for that thread, not 3.
alt Doesn't exist yet
    BE -> DB: convert date + time to timestamp, add msg to DB (type="MESSAGE")
    BE -> DB: search for existing drafts on thread_id
    alt draft found
        BE -> DB: remove draft
        BE -> DB: remove agent
end
BE -> AGENT: Should I reply? (input = thread in [{}], system_prompt)
loop 
    alt toolcall suggest_draft
        AGENT -> BE: suggest_draft (input = draft content)
        BE -> DB: search for new message in DB
        alt new message found
            BE -> DB: don't store draft
        else no new message found
            BE -> DB: add draft message to DB (with msgID, thread_name, msg_content, type="DRAFT", agent_id)
            BE -> DB: add agent to agents table (key = agent_id, value = messages json)
        end
    else toolcall end_work
        AGENT -> BE: end_work
        BE -> BE: stop
    else toolcall find_similar_messages
        AGENT -> BE: find_similar_messages
        BE -> MCP: find similar messages
        MCP --> BE: similar messages
        BE --> AGENT: similar messages
    else toolcall semantic_search
        AGENT -> BE: semantic_search
        BE -> MCP: semantic search
        MCP --> BE: similar messages
        BE --> AGENT: similar messages
    end
end
@enduml
